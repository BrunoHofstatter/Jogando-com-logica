Technical Architecture - Jogando com LÃ³gica

1. Game Engine Structure
The core of the project is the `GameEngine` class (Singleton), located in `src/AA_baseGame/Logic/gameEngine.ts`. It manages the entire lifecycle of a game session, agnostic of the specific game rules.

- State Management: It maintains the `GameState` (board, players, turn count, history, etc.).
- Event System: Implements an observer pattern (`addEventListener`, `emitEvent`) to notify the UI of changes (e.g., `turn_start`, `action_executed`, `win`).
- Action Execution: The `executeAction` method handles the flow of a turn:
  1. Validates the move using `GameRules.validateMove`.
  2. Checks resource costs (Energy/Moves).
  3. Executes the action via `GameRules.executeAction`.
  4. Checks for win conditions via `GameRules.checkWinCondition`.
  5. Manages turn transitions.

2. Core Interfaces (`src/AA_baseGame/Logic/types.ts`)

- GameConfig: Defines static settings like board dimensions, player count, initial piece setup, and turn constraints (time limits, moves per turn).
- GameRules: An interface that every game must implement. It bridges the generic engine with specific game logic. Key methods:
  - `validateMove(state, action)`: Boolean check for move legality.
  - `executeAction(state, action)`: Modifies the state based on the action.
  - `checkWinCondition(state)`: Returns a `WinResult` if a player wins.
  - `getAvailableActions(state)`: Returns all legal moves (crucial for AI).
- GameState: The dynamic snapshot of the game. Includes the `board` (grid of `Piece` objects), `currentPlayer`, `remainingMoves`, and custom `gameData`.
- TurnAction: Represents a player's intent. Properties: `type` (move, capture, place), `from`/`to` (coordinates), and optional data.

3. How It Works
- Initialization: `gameEngine.initializeGame(config, rules)` creates the initial state.
- Turn Loop: The UI calls `gameEngine.executeAction`. The engine validates the action against the active `GameRules`. If valid, the state is updated, and events are fired. The UI listens to these events to re-render.
- Win Conditions: Checked automatically after every action. If a winner is found, the game phase changes to "ended".

4. AI Integration
AI is implemented as a layer on top of the Game Engine, specifically for competitive games (Math War, Crown Chase, SPTTT).

- Architecture: Each game has an `aiPlayer.ts` file exporting a `getAIMove(state, rules, difficulty)` function.
- Hook: The UI detects if the current player is AI (e.g., Player 0 in MathWar). If so, it requests a move from `getAIMove` and passes it to `gameEngine.executeAction`.
- Difficulties (1-4):
  - Level 1 (Random): Picks a random valid move.
  - Level 2 (Simple/Heuristic): Prioritizes captures or immediate gains (e.g., finding the "Captain" in Math War).
  - Level 3 (Medium): Uses basic scoring or limited lookahead to evaluate moves.
  - Level 4 (Hard): Implements more advanced algorithms like Minimax (Crown Chase) or optimized heuristics with deep scoring (Math War, SPTTT) to provide a strong challenge.
